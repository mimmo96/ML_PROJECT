import itertools
import numpy as np
import Matrix_io
import neural_network
import math
import ensemble
from Model_Selection import ThreadPool_average

def cv_k_fold(grid, epochs, training_set, test_set, type_problem, k_fold = 4):
    num_training = -1
    #divide dataset into K distinct and equal D_1, ..., D_K
    size_validation = training_set.input().shape[0] // k_fold
    top_NN = ensemble.ensemble()
    
    for hyperparameter in grid:
        #hyperparameters
        early_stopping = hyperparameter[0] 
        batch_size = hyperparameter[1]
        function = hyperparameter[2]
        fun_out = hyperparameter[3]
        units = hyperparameter[4]
        learning_rate = hyperparameter[5]
        alfa = hyperparameter[6]
        v_lambda = hyperparameter[7]
        type_weights = hyperparameter[8]
        num_training += 1
        #it will cointain K models generated by k partition of TR
        NN_k_fold = []
        for k in range(k_fold):
            
            if k == k_fold-1:
                last_set = True
            else:
                last_set = False
            #create training and validation set for Kth iteration of k_fold
            training_k, validation_k = training_set.create_fold(k*size_validation, (k+1)*size_validation, last_set)
            
            #for each model, train "trials_for_model" times with different initialization type_weightshts
            loss_tr_tot, loss_vl_tot, MEE_tot_tr, MEE_tot_vl, acc_tot_tr, acc_tot_vl, std, model = ThreadPool_average(type_problem,fun_out, training_k, validation_k, batch_size, epochs, num_training,units, alfa, v_lambda, learning_rate, len(units) - 2, type_weights, function, early_stopping)
            
            NN_k_fold.append(ensemble.stat_model(model, loss_tr_tot, loss_vl_tot, MEE_tot_tr, MEE_tot_vl, acc_tot_tr, acc_tot_vl, std, num_training))
            
        #best_NN_fold = tuple (neaural network, mean_mse, mean_mee, num_training) it contains best model btw k models generated 
        # and the mean mse btw k models
        NN_k_fold = ensemble.ensemble(NN_k_fold, [], k_fold)
        best_NN_k_fold = NN_k_fold.best_neural_network() 
        
        top_NN.k_is_in_top(best_NN_k_fold)
    
    #retraining with early stopping
    #
    #           write here
    #
    #   
    return top_NN